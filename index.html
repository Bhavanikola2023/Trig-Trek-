<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mission: Trig Trek - Mapping a Futuristic Island</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      overflow: hidden;
      background-color: #050520;
      color: white;
    }
    #canvas-container {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    #ui-container {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 300px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      padding: 15px;
      z-index: 100;
      max-height: 95vh;
      overflow-y: auto;
    }
    h1, h2, h3 {
      color: #4fd1c5;
      margin-bottom: 10px;
    }
    h1 {
      text-align: center;
      font-size: 1.5em;
      margin-bottom: 15px;
      text-shadow: 0 0 10px rgba(79, 209, 197, 0.7);
    }
    h2 {
      font-size: 1.2em;
      border-bottom: 1px solid #4fd1c5;
      padding-bottom: 5px;
      margin-top: 20px;
    }
    button {
      background-color: #4fd1c5;
      color: black;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      margin: 5px 0;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: bold;
    }
    button:hover {
      background-color: #38b2ac;
      transform: scale(1.05);
    }
    .module-container {
      margin-bottom: 15px;
      display: none; /* Hide content divs by default */
    }
    .active {
      display: block;
    }
    .input-group {
      margin-bottom: 10px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      color: #c6f6f5;
    }
    input[type="number"], input[type="range"] {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #4fd1c5;
      background-color: rgba(0, 0, 0, 0.5);
      color: white;
    }
    input[type="range"] {
      height: 5px;
      background: #4fd1c5;
      outline: none;
      -webkit-appearance: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 15px;
      height: 15px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
    }
    .result {
      background-color: rgba(79, 209, 197, 0.2);
      padding: 8px;
      border-radius: 5px;
      margin-top: 10px;
      border-left: 3px solid #4fd1c5;
    }
    .tab-container {
      display: flex;
      flex-wrap: wrap; /* Allow tabs to wrap */
      margin-bottom: 15px;
    }
    .tab {
      flex: 1 1 auto; /* Allow tabs to shrink and grow, but base size on content */
      text-align: center;
      padding: 8px;
      background-color: rgba(79, 209, 197, 0.2);
      cursor: pointer;
      border: 1px solid #38b2ac;
      margin: 1px; /* Add small margin for wrapping */
      border-radius: 3px; /* Slightly rounded corners */
      font-size: 0.85em; /* Slightly smaller font for more tabs */
      min-width: 60px; /* Minimum width to prevent excessive shrinking */
    }
    .tab.active {
      background-color: #4fd1c5;
      color: black;
      font-weight: bold;
    }
    #loading-screen {
      position: absolute;
      width: 100%;
      height: 100%;
      background-color: #050520;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      z-index: 1000;
    }
    #loading-progress {
      width: 300px;
      height: 20px;
      background-color: rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      margin-top: 20px;
      overflow: hidden;
    }
    #progress-bar {
      width: 0%;
      height: 100%;
      background-color: #4fd1c5;
      transition: width 0.3s;
    }
    .header-buttons {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
    }
    .help-btn {
      background-color: #4c51bf;
      padding: 5px 10px;
    }
    .hint {
      color: #fbd38d;
      margin-top: 8px;
      font-style: italic;
      font-size: 0.9em;
      display: none;
    }
    #welcome-modal, #info-modal, #help-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      max-width: 600px;
      background-color: rgba(0, 0, 0, 0.85);
      border-radius: 10px;
      padding: 20px;
      z-index: 200;
      box-shadow: 0 0 20px rgba(79, 209, 197, 0.5);
      display: none;
      color: white;
    }
    .modal-content {
      max-height: 70vh;
      overflow-y: auto;
      padding-right: 10px;
      scrollbar-width: thin;
      scrollbar-color: #4fd1c5 rgba(0, 0, 0, 0.5);
    }
    .modal-content::-webkit-scrollbar {
      width: 8px;
    }
    .modal-content::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 10px;
    }
    .modal-content::-webkit-scrollbar-thumb {
      background-color: #4fd1c5;
      border-radius: 10px;
      border: 2px solid rgba(0, 0, 0, 0.5);
    }
    #story-progress {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      border-radius: 10px;
      padding: 10px;
      max-width: 300px;
      z-index: 100;
    }
    .progress-item {
      margin-bottom: 5px;
      display: flex;
      align-items: center;
    }
    .progress-check {
      margin-right: 8px;
      color: #4fd1c5;
      display: inline-block;
      width: 20px;
      text-align: center;
    }
    .progress-item span:last-child {
      transition: opacity 0.3s, text-decoration 0.3s;
    }
    .completed span:last-child {
      text-decoration: line-through;
      opacity: 0.7;
    }
    .tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      pointer-events: none;
      z-index: 300;
      display: none;
      font-size: 14px;
      max-width: 200px;
    }
    .color-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin-right: 10px;
    }
    .color-box {
      width: 15px;
      height: 15px;
      margin-right: 5px;
      border-radius: 3px;
    }
    .modal-close-btn {
        background-color: #4c51bf;
        color: white;
        border: none;
        padding: 8px 15px;
        border-radius: 5px;
        cursor: pointer;
        display: block;
        margin: 20px auto 0;
        font-weight: bold;
        transition: background-color 0.2s;
    }
    .modal-close-btn:hover {
        background-color: #3b40ab;
    }
    .completion-message {
        color: #48bb78;
        font-weight: bold;
        margin-top: 10px;
    }
    #ui-container::-webkit-scrollbar {
        width: 6px;
    }
    #ui-container::-webkit-scrollbar-track {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
    }
    #ui-container::-webkit-scrollbar-thumb {
        background-color: #38b2ac;
        border-radius: 10px;
    }
    #ui-container {
        scrollbar-width: thin;
        scrollbar-color: #38b2ac rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <div id="loading-screen">
    <h1>MISSION: TRIG TREK</h1>
    <p>Mapping a Futuristic Island</p>
    <div id="loading-progress">
      <div id="progress-bar"></div>
    </div>
    <p id="loading-text">Initializing...</p>
  </div>

  <div id="canvas-container"></div>

  <div id="welcome-modal">
    <div class="modal-content">
      <h1>Welcome to Trig Trek!</h1>
      <p>You are part of an elite team of scientists and explorers sent to map a newly discovered polar island.</p>
      <p>This island, named "Trigonomia," has appeared suddenly following a seismic event in the Arctic. Your mission is to map this mysterious landmass using your mathematical skills.</p>
      <h2>Your Mission Objectives:</h2>
      <p>1. <strong>Survey the Land</strong> - Use trigonometric principles to measure triangular regions</p>
      <p>2. <strong>Map Vector Fields</strong> - Record wind patterns and currents using vector mathematics</p>
      <p>3. <strong>Document Polar Features</strong> - Map unusual formations using polar coordinates</p>
      <p>4. <strong>Track Movement Patterns</strong> - Use parametric equations to track migration paths</p>
      <p>This simulation will help you apply Chapter 8 concepts in a practical, engaging way.</p>
      <p>Ready to begin your adventure?</p>
      <div style="text-align: center; margin-top: 20px;">
        <button id="start-mission-btn" class="modal-close-btn" style="background-color: #4fd1c5; color: black;">START MISSION</button>
      </div>
    </div>
  </div>

  <div id="info-modal">
    <div class="modal-content">
      <h1 style="color: #4fd1c5;">Concept Information</h1>
      <p>This simulation covers key concepts from trigonometry and vector mathematics:</p>
      
      <h2 style="color: #4fd1c5; margin-top: 15px;">1. Triangulation</h2>
      <p>Uses the Law of Sines and the Law of Cosines to find unknown sides and angles of triangles. Essential for surveying and distance measurement.</p>
      <div style="background-color: rgba(79, 209, 197, 0.1); padding: 10px; border-radius: 5px; margin-top: 5px;">
        <h3 style="color: #fbd38d; margin-bottom: 5px;">Real-World Applications:</h3>
        <p><strong>Land Surveying for Construction:</strong> Engineers use triangulation to measure distances and angles when planning the layout of new construction projects. By establishing known points and calculating unknown distances with the Law of Sines or Cosines, surveyors create accurate maps that inform everything from building foundations to road designs.</p>
        <p><strong>GPS and Navigation:</strong> Triangulation principles are foundational to the Global Positioning System (GPS). Satellites and receivers use a form of triangulation to pinpoint exact locations on Earth. Students familiar with these trigonometric methods can better appreciate how technology converts raw measurements into navigational data.</p>
      </div>
      
      <h2 style="color: #4fd1c5; margin-top: 15px;">2. Vectors</h2>
      <p>Represents quantities with magnitude and direction (like wind or forces). Explores vector components, magnitude, and the dot product.</p>
      <div style="background-color: rgba(79, 209, 197, 0.1); padding: 10px; border-radius: 5px; margin-top: 5px;">
        <h3 style="color: #fbd38d; margin-bottom: 5px;">Real-World Applications:</h3>
        <p><strong>Physics and Engineering Applications:</strong> In mechanics and engineering, vectors are critical for describing forces, velocities, or accelerations. For instance, an engineer might use vector addition to determine the resultant force acting on a bridge, ensuring the structure can withstand varying loads from traffic and wind.</p>
        <p><strong>Weather Forecasting:</strong> Meteorologists use vectors to model wind patterns and ocean currents. Understanding how to calculate and interpret vector components and dot products helps in creating accurate models that predict weather changes and natural phenomena like storms.</p>
      </div>
      
      <h2 style="color: #4fd1c5; margin-top: 15px;">3. Polar Coordinates</h2>
      <p>Describes points using distance from the origin and an angle. Used to map features like rose curves or cardioids.</p>
      <div style="background-color: rgba(79, 209, 197, 0.1); padding: 10px; border-radius: 5px; margin-top: 5px;">
        <h3 style="color: #fbd38d; margin-bottom: 5px;">Real-World Applications:</h3>
        <p><strong>Computer Graphics and Animation:</strong> The conversion of polar coordinates to rectangular forms is key in computer graphics. When animating effects like spirals or flower-like patterns, programmers use polar equations to generate visuals. This knowledge directly translates to designing elements in video games, movies, or digital art.</p>
        <p><strong>Engineering and Design:</strong> Certain engineering problems require the description of curves and circular patterns. For example, the design of gears or the layout of circular seating in a theater often starts with the manipulation of polar equations. Understanding these concepts enables precise designs that fit specific criteria.</p>
      </div>
      
      <h2 style="color: #4fd1c5; margin-top: 15px;">4. Parametric Equations</h2>
      <p>Defines coordinates in terms of a parameter (often time). Used to trace moving paths, like circular or more complex curves.</p>
      <div style="background-color: rgba(79, 209, 197, 0.1); padding: 10px; border-radius: 5px; margin-top: 5px;">
        <h3 style="color: #fbd38d; margin-bottom: 5px;">Real-World Applications:</h3>
        <p><strong>Robotics and Automation:</strong> Parametric equations model the paths that robots take to reach targets or navigate obstacles. In robotic arms or autonomous vehicles, adjusting parameters directly affects motion, ensuring smooth and efficient movement along curved trajectories.</p>
        <p><strong>Animation and Simulation:</strong> In digital animation and simulations, parametric equations are used to create smooth, time-based movements. For example, animators might use them to model the flight of a bird or the motion of particles in a fluid, producing realistic and dynamic scenes that react to changes over time.</p>
      </div>
      
      <p style="margin-top: 15px;">Experiment with the different modules to see these concepts in action!</p>
      <button class="modal-close-btn" id="close-info-modal">Close</button>
    </div>
  </div>

  <div id="help-modal">
    <div class="modal-content">
      <h1 style="color: #4c51bf;">Animation Help</h1>
      <p>Here's how to interact with the animations:</p>
      <ul>
        <li><strong>General View:</strong> Rotate, zoom, and pan using your mouse/touchpad.</li>
        <li><strong>Center Map Tab:</strong> Reset the camera to the default overview.</li>
        <li><strong>Zoom In Tab:</strong> Get a closer view of the active module's 3D elements.</li>
        <li><strong>Triangles:</strong> Select a region, input known values, and click 'Calculate Missing Values' to update the 3D triangle.</li>
        <li><strong>Vectors:</strong> Input vector components, then click 'Update Vectors' and 'Calculate Dot Product' for analysis.</li>
        <li><strong>Polar:</strong> Select a feature type and adjust sliders. Click 'Convert to Rectangular (Approx.)' for conversion.</li>
        <li><strong>Parametric:</strong> Select a path type and adjust parameters. Use 'Pause/Resume Animation' to control movement.</li>
        <li><strong>Hints:</strong> Use the 'Show Hint' button in each module for formula reminders.</li>
      </ul>
      <button class="modal-close-btn" id="close-help-modal">Close</button>
    </div>
  </div>

  <div id="ui-container">
    <div class="header-buttons">
      <button id="return-overview">Overview</button>
      <button class="help-btn" id="show-help-header">Help</button>
    </div>
    <h1>MISSION: TRIG TREK</h1>
    <div class="tab-container">
      <div class="tab active" data-module="overview">Overview</div>
      <div class="tab" data-module="triangulation">Triangles</div>
      <div class="tab" data-module="vectors">Vectors</div>
      <div class="tab" data-module="polar">Polar</div>
      <div class="tab" data-module="parametric">Parametric</div>
      <div class="tab" data-module="center-map">Center Map</div>
      <div class="tab" data-module="zoom-in">Zoom In</div>
      <div class="tab" data-module="info">Info</div>
      <div class="tab" data-module="help">Help</div>
    </div>

    <div id="overview" class="module-container active">
      <h2>Mission Control</h2>
      <p>Welcome to Trigonomia Island! Use your math skills to explore and map this mysterious location.</p>
      <h2>Modules</h2>
      <p>Select a module tab above or use the buttons below:</p>
      <button class="module-btn" data-module="triangulation">Land Survey (Triangulation)</button>
      <button class="module-btn" data-module="vectors">Vector Terrain Mapping</button>
      <button class="module-btn" data-module="polar">Polar Ecology Mapping</button>
      <button class="module-btn" data-module="parametric">Time-Driven Paths</button>
      <h2>Progress</h2>
      <div id="progress-display">
        <p>Tasks completed: 0/4</p>
      </div>
    </div>

    <div id="triangulation" class="module-container">
      <h2>Land Survey (Triangulation)</h2>
      <p>Use the Law of Sines and Cosines to calculate missing sides and angles of triangular regions.</p>
      <div class="input-group">
        <label for="triangle-select">Select Triangle Region:</label>
        <select id="triangle-select">
          <option value="1">Region Alpha</option>
          <option value="2">Region Beta</option>
          <option value="3">Region Gamma</option>
        </select>
      </div>
      <div id="triangle-info" class="result">
        <p>Select a triangle region to view measurements.</p>
      </div>
      <div class="input-group">
        <label for="triangle-problem-type">Triangle Type:</label>
        <select id="triangle-problem-type">
          <option value="SSS">SSS - Three Sides</option>
          <option value="SAS">SAS - Two Sides and Included Angle</option>
          <option value="ASA">ASA - Two Angles and Included Side</option>
          <option value="AAS">AAS - Two Angles and Non-included Side</option>
        </select>
      </div>
      <div id="triangle-inputs"></div>
      <button id="solve-triangle">Calculate Missing Values</button>
      <button id="triangle-hint-btn">Show Hint</button>
      <div id="triangle-hint" class="hint">
        Remember: Law of Sines works well with angles and opposite sides; Law of Cosines is best with three sides or two sides and their included angle. Area = 0.5 * a * b * sin(C).
      </div>
      <div id="triangle-result" class="result">
        <p>Results will appear here.</p>
      </div>
      <button id="complete-triangulation" style="background-color: #48bb78;">Mark Task Complete</button>
    </div>

    <div id="vectors" class="module-container">
      <h2>Vector Terrain Mapping</h2>
      <p>Map wind patterns and forces using vectors and calculate dot products.</p>
      <div class="input-group">
        <label>Vector 1 (Direction, km):</label>
        <div style="display: flex; gap: 5px;">
          <input type="number" id="vector1-x" placeholder="x" value="3" step="0.5">
          <input type="number" id="vector1-y" placeholder="y" value="4" step="0.5">
          <input type="number" id="vector1-z" placeholder="z" value="0" step="0.5">
        </div>
      </div>
      <div class="input-group">
        <label>Vector 2 (Direction, km):</label>
        <div style="display: flex; gap: 5px;">
          <input type="number" id="vector2-x" placeholder="x" value="-2" step="0.5">
          <input type="number" id="vector2-y" placeholder="y" value="1" step="0.5">
          <input type="number" id="vector2-z" placeholder="z" value="0" step="0.5">
        </div>
      </div>
      <button id="calculate-vector">Update Vectors</button>
      <button id="calculate-dot-product">Calculate Dot Product</button>
      <button id="vector-hint-btn">Show Hint</button>
      <div id="vector-hint" class="hint">
        The dot product (v1 · v2 = x1*x2 + y1*y2 + z1*z2) reveals if vectors are perpendicular (result = 0) or the angle between them.
      </div>
      <div id="vector-result" class="result">
        <p>Vector analysis will appear here.</p>
      </div>
      <button id="complete-vectors" style="background-color: #48bb78;">Mark Task Complete</button>
    </div>

    <div id="polar" class="module-container">
      <h2>Polar Ecology Mapping</h2>
      <p>Map unique natural features using polar equations.</p>
      <div class="input-group">
        <label for="polar-type">Feature Type:</label>
        <select id="polar-type">
          <option value="rose">Rose Curve (Flower Fields)</option>
          <option value="limaçon">Limaçon (Coastal Formations)</option>
          <option value="lemniscate">Lemniscate (Frozen Lakes)</option>
          <option value="cardioid">Cardioid (Heart-shaped Cave)</option>
          <option value="spiral">Spiral (Mountain Path)</option>
        </select>
      </div>
      <div class="input-group">
        <label for="polar-a">Size Parameter (a): <span id="polar-a-value">2.0</span></label>
        <input type="range" id="polar-a" min="0.1" max="5" step="0.1" value="2">
      </div>
      <div class="input-group">
        <label for="polar-n">Shape Parameter (n): <span id="polar-n-value">3</span></label>
        <input type="range" id="polar-n" min="1" max="8" step="1" value="3">
      </div>
      <div class="input-group">
        <label>Polar Equation:</label>
        <div id="polar-equation" class="result">r = a·cos(nθ)</div>
      </div>
      <button id="convert-polar">Convert to Rectangular (Approx.)</button>
      <button id="polar-hint-btn">Show Hint</button>
      <div id="polar-hint" class="hint">
        For rose curves, n determines the number of petals (odd n: n petals; even n: 2n petals). Conversion: x = r·cos(θ), y = r·sin(θ).
      </div>
      <div id="polar-result" class="result">
        <p>Select a feature type to begin mapping.</p>
      </div>
      <button id="complete-polar" style="background-color: #48bb78;">Mark Task Complete</button>
    </div>

    <div id="parametric" class="module-container">
      <h2>Time-Driven Paths</h2>
      <p>Track migration patterns using parametric equations.</p>
      <div class="input-group">
        <label for="parametric-type">Path Type:</label>
        <select id="parametric-type">
          <option value="circle">Circular Path (Bird Migration)</option>
          <option value="cycloid">Cycloid (Rolling Object)</option>
          <option value="lissajous">Lissajous (Drone Survey Pattern)</option>
          <option value="butterfly">Butterfly Curve (Rare Species Path)</option>
        </select>
      </div>
      <div class="input-group">
        <label for="param-speed">Animation Speed: <span id="param-speed-value">0.5</span></label>
        <input type="range" id="param-speed" min="0.1" max="2" step="0.1" value="0.5">
      </div>
      <div class="input-group">
        <label for="param-a">X Parameter (a): <span id="param-a-value">2.0</span></label>
        <input type="range" id="param-a" min="0.5" max="5" step="0.1" value="2">
      </div>
      <div class="input-group">
        <label for="param-b">Y Parameter (b): <span id="param-b-value">2.0</span></label>
        <input type="range" id="param-b" min="0.5" max="5" step="0.1" value="2">
      </div>
      <div class="input-group">
        <label>Parametric Equations (x(t), z(t)):</label>
        <div id="parametric-equation" class="result">
          x = a·cos(t)<br>
          z = a·sin(t)
        </div>
      </div>
      <button id="toggle-animation">Pause Animation</button>
      <button id="parametric-hint-btn">Show Hint</button>
      <div id="parametric-hint" class="hint">
        The parameter t represents time. Adjust 'a' and 'b' to modify the path's shape and size.
      </div>
      <div id="parametric-result" class="result">
        <p>Select a path type to begin tracking.</p>
      </div>
      <button id="complete-parametric" style="background-color: #48bb78;">Mark Task Complete</button>
    </div>

    <div id="center-map" class="module-container"><h2>Map Centered</h2><p>Camera reset to default view.</p></div>
    <div id="zoom-in" class="module-container"><h2>Zoomed In</h2><p>Camera moved closer to the active element.</p></div>
    <div id="info" class="module-container"><h2>Info</h2><p>Displaying conceptual information...</p></div>
    <div id="help" class="module-container"><h2>Help</h2><p>Displaying interaction help...</p></div>
  </div>

  <div id="story-progress">
    <h3>Mission Log</h3>
    <div class="progress-item">
      <span class="progress-check">☐</span>
      <span>Land Survey (Triangulation)</span>
    </div>
    <div class="progress-item">
      <span class="progress-check">☐</span>
      <span>Vector Terrain Mapping</span>
    </div>
    <div class="progress-item">
      <span class="progress-check">☐</span>
      <span>Polar Ecology Mapping</span>
    </div>
    <div class="progress-item">
      <span class="progress-check">☐</span>
      <span>Time-Driven Paths</span>
    </div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
  <script>
    // Main application state
    const appState = {
      completedTasks: {
        triangulation: false,
        vectors: false,
        polar: false,
        parametric: false
      },
      currentModule: 'overview',
      animationRunning: true,
      paramTime: 0
    };

    let scene, camera, renderer, controls;
    let clock = new THREE.Clock();

    let island, triangleGroup, vectorGroup, polarGroup, parametricGroup;
    let triangleRegions = [];
    let vectorArrows = { vector1: null, vector2: null, resultVector: null };
    let polarCurve = null;
    let parametricPath = null;
    let parametricObject = null;

    const modules = ['overview', 'triangulation', 'vectors', 'polar', 'parametric', 'center-map', 'zoom-in', 'info', 'help'];
    const contentModules = ['overview', 'triangulation', 'vectors', 'polar', 'parametric'];

    const loadingScreen = document.getElementById('loading-screen');
    const progressBar = document.getElementById('progress-bar');
    const loadingText = document.getElementById('loading-text');

    const welcomeModal = document.getElementById('welcome-modal');
    const startMissionBtn = document.getElementById('start-mission-btn');
    const infoModal = document.getElementById('info-modal');
    const helpModal = document.getElementById('help-modal');
    const closeInfoModalBtn = document.getElementById('close-info-modal');
    const closeHelpModalBtn = document.getElementById('close-help-modal');

    const triangleData = [
      {
        name: "Region Alpha",
        sides: [12, 8, 0],
        angles: [0, 0, 0],
        color: 0xff5555,
        defaultProblem: 'SSS',
        position: new THREE.Vector3(-8, 0.1, -5)
      },
      {
        name: "Region Beta",
        sides: [9, 0, 11],
        angles: [0, 45, 0],
        color: 0x55ff55,
        defaultProblem: 'SAS',
        position: new THREE.Vector3(5, 0.1, -8)
      },
      {
        name: "Region Gamma",
        sides: [0, 7, 0],
        angles: [50, 0, 60],
        color: 0x5555ff,
        defaultProblem: 'AAS',
        position: new THREE.Vector3(0, 0.1, 9)
      }
    ];

    function initLoading() {
      loadingScreen.style.display = 'flex';
      welcomeModal.style.display = 'none';
      let progress = 0;
      const loadingInterval = setInterval(() => {
        progress += Math.random() * 5 + 2;
        if (progress >= 100) {
          progress = 100;
          clearInterval(loadingInterval);
          setTimeout(() => {
            loadingScreen.style.display = 'none';
            gsap.from(welcomeModal, { duration: 0.5, opacity: 0, y: -30, ease: "power2.out", onStart: () => welcomeModal.style.display = 'block' });
          }, 500);
        }
        progressBar.style.width = `${progress}%`;
        loadingText.textContent = `Loading assets... ${Math.floor(progress)}%`;
      }, 80);
    }

    function loadScript(url, callback) {
      const script = document.createElement('script');
      script.type = 'text/javascript';
      script.src = url;
      script.onload = callback;
      script.onerror = () => console.error(`Failed to load script: ${url}`);
      document.head.appendChild(script);
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x050520);
      scene.fog = new THREE.Fog(0x050520, 50, 150);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 25, 40);
      camera.lookAt(0, 0, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.getElementById('canvas-container').appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x607080, 0.8);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(15, 30, 20);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 100;
      directionalLight.shadow.camera.left = -30;
      directionalLight.shadow.camera.right = 30;
      directionalLight.shadow.camera.top = 30;
      directionalLight.shadow.camera.bottom = -30;
      scene.add(directionalLight);

      const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x556B2F, 0.6);
      scene.add(hemisphereLight);

      loadScript('https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js', () => {
        if (typeof THREE.OrbitControls === 'function') {
          controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.1;
          controls.screenSpacePanning = false;
          controls.minDistance = 5;
          controls.maxDistance = 100;
          controls.maxPolarAngle = Math.PI / 2 - 0.05;
          controls.target.set(0, 0, 0);
          controls.update();
          console.log("OrbitControls loaded and initialized.");
        } else {
          console.error("THREE.OrbitControls not found after loading script.");
        }
      });

      createIsland();
      createTriangleRegions();
      createVectorGroup();
      createPolarGroup();
      createParametricGroup();

      const gridHelper = new THREE.GridHelper(60, 60, 0x555555, 0x333333);
      gridHelper.position.y = -0.05;
      scene.add(gridHelper);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function createIsland() {
      island = new THREE.Group();
      scene.add(island);
      const islandShape = new THREE.Shape();
      const islandRadius = 20;
      const segments = 64;
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        const radiusVariation = 1 + Math.sin(theta * 5) * 0.2 + Math.cos(theta * 2) * 0.15;
        const x = Math.cos(theta) * islandRadius * radiusVariation;
        const y = Math.sin(theta) * islandRadius * radiusVariation;
        if (i === 0) islandShape.moveTo(x, y);
        else islandShape.lineTo(x, y);
      }
      const islandGeometry = new THREE.ShapeGeometry(islandShape);
      const islandMaterial = new THREE.MeshStandardMaterial({
        map: createTerrainTexture(),
        roughness: 0.9,
        metalness: 0.1
      });
      const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
      islandMesh.rotation.x = -Math.PI / 2;
      islandMesh.receiveShadow = true;
      island.add(islandMesh);

      const waterGeometry = new THREE.PlaneGeometry(200, 200);
      const waterCanvas = document.createElement('canvas');
      waterCanvas.width = 64; waterCanvas.height = 64;
      const waterCtx = waterCanvas.getContext('2d');
      waterCtx.fillStyle = '#0077be';
      waterCtx.fillRect(0,0,64,64);
      waterCtx.fillStyle = 'rgba(255,255,255,0.2)';
      for(let i=0; i<50; i++){ waterCtx.fillRect(Math.random()*64, Math.random()*64, 2, 1);}
      const waterTexture = new THREE.CanvasTexture(waterCanvas);
      waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
      waterTexture.repeat.set(10, 10);
      const waterMaterial = new THREE.MeshStandardMaterial({
        map: waterTexture,
        transparent: true,
        opacity: 0.85,
        roughness: 0.2,
        metalness: 0.3,
        envMapIntensity: 0.5
      });
      const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
      waterMesh.rotation.x = -Math.PI / 2;
      waterMesh.position.y = -0.2;
      waterMesh.receiveShadow = true;
      scene.add(waterMesh);

      for (let i = 0; i < 7; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 10 + Math.random() * 8;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const baseSize = 1.5 + Math.random() * 1.5;
        const height = 3 + Math.random() * 4;
        const coneGeometry = new THREE.ConeGeometry(baseSize, height, 6 + Math.floor(Math.random() * 4));
        const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x665544, roughness: 0.8 });
        const cone = new THREE.Mesh(coneGeometry, coneMaterial);
        cone.position.set(x, height / 2 - 0.1, z);
        cone.castShadow = true;
        cone.receiveShadow = true;
        island.add(cone);
      }

      for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const radius = 3 + Math.random() * 15;
        let tooCloseToMountain = false;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        island.children.forEach(child => {
          if(child.geometry instanceof THREE.ConeGeometry){
            if(child.position.distanceTo(new THREE.Vector3(x, 0, z)) < child.geometry.parameters.radius * 1.5) {
              tooCloseToMountain = true;
            }
          }
        });
        if(tooCloseToMountain || radius > islandRadius * 0.9) continue;
        const trunkHeight = 0.8 + Math.random() * 0.7;
        const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.15, trunkHeight, 6);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.9 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.set(x, trunkHeight / 2 - 0.1, z);
        trunk.castShadow = true;
        const leavesHeight = 1.5 + Math.random();
        const leavesGeometry = new THREE.ConeGeometry(0.6 + Math.random() * 0.3, leavesHeight, 7);
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8 });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.set(0, trunkHeight / 2 + leavesHeight / 2 - 0.1, 0);
        leaves.castShadow = true;
        trunk.add(leaves);
        island.add(trunk);
      }
    }

    function createTerrainTexture() {
      const size = 128;
      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = `hsl(${90 + Math.random()*30}, 40%, 35%)`;
      ctx.fillRect(0, 0, size, size);
      for (let i = 0; i < 8000; i++) {
        const x = Math.random() * size;
        const y = Math.random() * size;
        const shade = Math.random() * 0.2 + 0.9;
        const baseColor = `hsl(${90 + Math.random()*30}, 40%, ${35 * shade}%)`;
        ctx.fillStyle = baseColor;
        ctx.fillRect(x, y, 2, 2);
      }
      return new THREE.CanvasTexture(canvas);
    }

    function createTriangleRegions() {
      triangleGroup = new THREE.Group();
      scene.add(triangleGroup);
      triangleData.forEach((data, index) => {
        const triangleGeometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
          0, 0, 0,
          1, 0, 0,
          0.5, 0, Math.sqrt(0.75)
        ]);
        triangleGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        triangleGeometry.computeVertexNormals();
        const triangleMaterial = new THREE.MeshStandardMaterial({
          color: data.color,
          transparent: true,
          opacity: 0.75,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const triangleMesh = new THREE.Mesh(triangleGeometry, triangleMaterial);
        triangleMesh.castShadow = false;
        triangleMesh.receiveShadow = true;
        triangleMesh.userData = { regionIndex: index, name: data.name };
        triangleMesh.position.copy(data.position);
        triangleGroup.add(triangleMesh);
        triangleRegions.push(triangleMesh);
      });
      triangleGroup.visible = false;
    }

    function makeTextSprite(message, parameters) {
      const fontface = parameters.fontface || 'Arial';
      const fontsize = parameters.fontsize || 18;
      const borderThickness = parameters.borderThickness === undefined ? 1 : parameters.borderThickness;
      const borderColor = parameters.borderColor || { r:0, g:0, b:0, a:1.0 };
      const backgroundColor = parameters.backgroundColor || { r:255, g:255, b:255, a:0.8 };
      const textColor = parameters.textColor || { r:0, g:0, b:0, a:1.0 };

      const canvas = document.createElement('canvas');
      const context = canvas.getContext('2d');
      context.font = "Bold " + fontsize + "px " + fontface;
      const metrics = context.measureText( message );
      const textWidth = metrics.width;
      const canvasWidth = textWidth + borderThickness*2 + 10;
      const canvasHeight = fontsize * 1.4 + borderThickness*2;
      canvas.width = canvasWidth;
      canvas.height = canvasHeight;
      context.font = "Bold " + fontsize + "px " + fontface;
      context.textAlign = 'center';
      context.textBaseline = 'middle';
      context.fillStyle = "rgba(" + backgroundColor.r + "," + backgroundColor.g + "," + backgroundColor.b + "," + backgroundColor.a + ")";
      context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + "," + borderColor.b + "," + borderColor.a + ")";
      context.lineWidth = borderThickness;
      const radius = 5;
      context.beginPath();
      context.moveTo(radius, 0);
      context.lineTo(canvasWidth - radius, 0);
      context.quadraticCurveTo(canvasWidth, 0, canvasWidth, radius);
      context.lineTo(canvasWidth, canvasHeight - radius);
      context.quadraticCurveTo(canvasWidth, canvasHeight, canvasWidth - radius, canvasHeight);
      context.lineTo(radius, canvasHeight);
      context.quadraticCurveTo(0, canvasHeight, 0, canvasHeight - radius);
      context.lineTo(0, radius);
      context.quadraticCurveTo(0, 0, radius, 0);
      context.closePath();
      context.fill();
      if (borderThickness > 0) {
        context.stroke();
      }
      context.fillStyle = "rgba("+textColor.r+", "+textColor.g+", "+textColor.b+", "+textColor.a+")";
      context.fillText( message, canvasWidth / 2, canvasHeight / 2);
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      const spriteMaterial = new THREE.SpriteMaterial( { map: texture } );
      const sprite = new THREE.Sprite( spriteMaterial );
      const aspect = canvasWidth / canvasHeight;
      sprite.scale.set(aspect * 1.5, 1.5, 1.0);
      return sprite;
    }

    function addTriangleMarkers(triangleMesh, data) {
      while(triangleMesh.children.length > 0) {
        const child = triangleMesh.children[0];
        if (child instanceof THREE.Sprite) {
          if (child.material.map) child.material.map.dispose();
          child.material.dispose();
        } else if (child.geometry) {
          child.geometry.dispose();
          if (child.material) {
            if (child.material.map) child.material.map.dispose();
            child.material.dispose();
          }
        }
        triangleMesh.remove(child);
      }
      const positions = triangleMesh.geometry.attributes.position;
      if (!positions) return;
      const vertices = [
        new THREE.Vector3().fromBufferAttribute(positions, 0),
        new THREE.Vector3().fromBufferAttribute(positions, 1),
        new THREE.Vector3().fromBufferAttribute(positions, 2)
      ];
      const sides = [
        { index: 0, value: data.sides[0], label: 'a', v1: vertices[1], v2: vertices[2] },
        { index: 1, value: data.sides[1], label: 'b', v1: vertices[0], v2: vertices[2] },
        { index: 2, value: data.sides[2], label: 'c', v1: vertices[0], v2: vertices[1] }
      ];
      sides.forEach(side => {
        if (side.value > 0) {
          const midPoint = new THREE.Vector3().addVectors(side.v1, side.v2).multiplyScalar(0.5);
          const direction = new THREE.Vector3().subVectors(side.v2, side.v1).normalize();
          const triangleNormal = new THREE.Vector3(0, 1, 0);
          const outwardNormal = new THREE.Vector3().crossVectors(direction, triangleNormal).normalize();
          midPoint.addScaledVector(outwardNormal, 0.3);
          midPoint.y += 0.1;
          const textSprite = makeTextSprite(`${side.label}=${side.value.toFixed(1)}`, {
            fontsize: 16,
            backgroundColor: { r:255, g:255, b:100, a:0.8 },
            textColor: { r:50, g:50, b:0, a:1.0 }
          });
          textSprite.position.copy(midPoint);
          triangleMesh.add(textSprite);
        }
      });
      const angles = [
        { index: 0, value: data.angles[0], label: 'A', pos: vertices[0] },
        { index: 1, value: data.angles[1], label: 'B', pos: vertices[1] },
        { index: 2, value: data.angles[2], label: 'C', pos: vertices[2] }
      ];
      angles.forEach(angle => {
        if (angle.value > 0) {
          const vertexPos = angle.pos.clone();
          const center = new THREE.Vector3()
                            .add(vertices[0])
                            .add(vertices[1])
                            .add(vertices[2])
                            .multiplyScalar(1/3);
          const inwardDir = new THREE.Vector3().subVectors(center, vertexPos).normalize();
          vertexPos.addScaledVector(inwardDir, 0.4);
          vertexPos.y += 0.1;
          const textSprite = makeTextSprite(`${angle.label}=${angle.value.toFixed(0)}°`, {
            fontsize: 16,
            backgroundColor: { r:100, g:200, b:255, a:0.8 },
            textColor: { r:0, g:0, b:100, a:1.0 }
          });
          textSprite.position.copy(vertexPos);
          triangleMesh.add(textSprite);
        }
      });
    }

    function createVectorGroup() {
      vectorGroup = new THREE.Group();
      scene.add(vectorGroup);
      vectorGroup.position.set(0, 0.5, 0);
      const originGeometry = new THREE.SphereGeometry(0.3, 16, 16);
      const originMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const origin = new THREE.Mesh(originGeometry, originMaterial);
      vectorGroup.add(origin);
      updateVectors();
      vectorGroup.visible = false;
    }

    function createVector(name, x, y, z, color) {
      const existingArrow = vectorArrows[name];
      const existingLabel = vectorGroup.children.find(child => child.userData.isLabel && child.userData.arrowName === name);
      if (existingArrow) vectorGroup.remove(existingArrow);
      if (existingLabel) {
        if (existingLabel.material.map) existingLabel.material.map.dispose();
        existingLabel.material.dispose();
        vectorGroup.remove(existingLabel);
      }
      const length = Math.sqrt(x * x + y * y + z * z);
      if (length < 0.01) {
        vectorArrows[name] = null;
        return null;
      }
      const dir = new THREE.Vector3(x, y, z).normalize();
      const origin = new THREE.Vector3(0, 0, 0);
      const headLength = Math.min(length * 0.2, 1.0);
      const headWidth = Math.min(length * 0.1, 0.5);
      const arrow = new THREE.ArrowHelper(dir, origin, length, color, headLength, headWidth);
      arrow.userData.vectorData = {x, y, z};
      vectorGroup.add(arrow);
      vectorArrows[name] = arrow;
      const labelText = `${name.replace('vector', 'v')}: (${x.toFixed(1)}, ${y.toFixed(1)}, ${z.toFixed(1)})`;
      const textSprite = makeTextSprite(labelText, {
        fontsize: 16,
        backgroundColor: { r:50, g:50, b:50, a:0.7 },
        textColor: { r: color >> 16 & 255, g: color >> 8 & 255, b: color & 255, a: 1.0 },
        borderThickness: 0
      });
      const labelPos = new THREE.Vector3(x, y, z).multiplyScalar(1.05).add(new THREE.Vector3(0, headLength * 0.5, 0));
      textSprite.position.copy(labelPos);
      textSprite.userData = { isLabel: true, arrowName: name };
      vectorGroup.add(textSprite);
      return arrow;
    }

    function createPolarGroup() {
      polarGroup = new THREE.Group();
      polarGroup.position.set(0, 0.1, 0);
      scene.add(polarGroup);
      const gridHelper = new THREE.PolarGridHelper(10, 16, 8, 64, 0xaaaaaa, 0x666666);
      gridHelper.position.y = 0.05;
      polarGroup.add(gridHelper);
      polarGroup.visible = false;
      updatePolarCurve();
    }

    function createPolarCurve(type, a, n) {
      if (polarCurve) {
        polarGroup.remove(polarCurve);
        polarCurve.geometry.dispose();
        polarCurve.material.dispose();
        polarCurve = null;
      }
      const oldSurface = polarGroup.children.find(child => child.userData && child.userData.isPolarSurface);
      if (oldSurface) {
        polarGroup.remove(oldSurface);
        oldSurface.geometry.dispose();
        oldSurface.material.dispose();
      }
      const points = [];
      const segments = 500;
      const maxTheta = (type === 'spiral') ? Math.PI * 6 : Math.PI * 2;
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * maxTheta;
        let r = 0;
        let validPoint = true;
        try {
          switch (type) {
            case 'rose':
              r = a * Math.cos(n * theta);
              break;
            case 'limaçon':
              r = 1 + a * Math.cos(theta);
              if (r < 0) validPoint = false;
              break;
            case 'lemniscate':
              const cos2Theta = Math.cos(2 * theta);
              if (cos2Theta >= 0) {
                r = a * Math.sqrt(cos2Theta);
              } else {
                validPoint = false;
              }
              break;
            case 'cardioid':
              r = a * (1 + Math.cos(theta));
              break;
            case 'spiral':
              r = a * theta / (Math.PI * 2);
              break;
            default: validPoint = false;
          }
          if (validPoint && !isNaN(r) && isFinite(r)) {
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            points.push(new THREE.Vector3(x, 0.1, z));
          }
        } catch (e) {
          console.error("Error calculating polar point:", type, theta, r, e);
        }
      }
      if (points.length > 1) {
        const curveGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const curveMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 3 });
        const curve = new THREE.Line(curveGeometry, curveMaterial);
        polarGroup.add(curve);
        polarCurve = curve;
        createPolarSurface(points, type);
      } else {
        polarCurve = null;
        console.warn("Not enough valid points to draw polar curve for:", type);
      }
      return polarCurve;
    }

    function createPolarSurface(points, type) {
      if (type === 'spiral' || points.length < 3) return;
      try {
        const shape = new THREE.Shape();
        const uniquePoints = points.filter((p, i, arr) => i === 0 || p.distanceTo(arr[i-1]) > 0.01);
        if(uniquePoints.length < 3) return;
        shape.moveTo(uniquePoints[0].x, uniquePoints[0].z);
        for (let i = 1; i < uniquePoints.length; i++) {
          shape.lineTo(uniquePoints[i].x, uniquePoints[i].z);
        }
        const closePath = (type !== 'limaçon' || uniquePoints[0].distanceTo(uniquePoints[uniquePoints.length - 1]) < 0.1);
        if (closePath) {
          shape.closePath();
        }
        const geometry = new THREE.ShapeGeometry(shape);
        let color;
        switch (type) {
          case 'rose': color = 0xff99cc; break;
          case 'limaçon': color = 0x66ccff; break;
          case 'lemniscate': color = 0xadd8e6; break;
          case 'cardioid': color = 0xff6666; break;
          default: color = 0x9370db;
        }
        const material = new THREE.MeshStandardMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.userData = { isPolarSurface: true };
        mesh.position.y = 0.09;
        mesh.renderOrder = -1;
        polarGroup.add(mesh);
      } catch (e) {
        console.warn("Could not create polar surface shape:", type, e);
      }
    }

    function createParametricGroup() {
      parametricGroup = new THREE.Group();
      parametricGroup.position.set(0, 0.1, 0);
      scene.add(parametricGroup);
      parametricGroup.visible = false;
      updateParametricPathVisuals();
    }

    function updateParametricPath(type, a, b) {
      if (parametricPath) {
        parametricGroup.remove(parametricPath);
        parametricPath.geometry.dispose();
        parametricPath.material.dispose();
        parametricPath = null;
      }
      if (parametricObject) {
        parametricGroup.remove(parametricObject);
        if (parametricObject.geometry) parametricObject.geometry.dispose();
        if (parametricObject.material) parametricObject.material.dispose();
        parametricObject = null;
      }
      const points = [];
      const segments = 500;
      let tMax = Math.PI * 2;
      if (type === 'cycloid') tMax = Math.PI * 4;
      if (type === 'butterfly') tMax = Math.PI * 12;
      if (type === 'lissajous') tMax = Math.PI * 2;
      for (let i = 0; i <= segments; i++) {
        const t = (i / segments) * tMax;
        let x=0, z=0;
        try {
          switch (type) {
            case 'circle':
              x = a * Math.cos(t);
              z = a * Math.sin(t);
              break;
            case 'cycloid':
              x = a * (t - Math.sin(t));
              z = a * (1 - Math.cos(t));
              break;
            case 'lissajous':
              const freqX = 2;
              const freqY = 3;
              x = a * Math.sin(freqX * t);
              z = b * Math.sin(freqY * t);
              break;
            case 'butterfly':
              const cosT = Math.cos(t);
              const sinT = Math.sin(t);
              const expr = (Math.exp(cosT) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t / 12), 5));
              x = a * sinT * expr;
              z = a * cosT * expr;
              break;
            default: throw new Error("Unknown parametric type");
          }
          if (!isNaN(x) && !isNaN(z) && isFinite(x) && isFinite(z)) {
            points.push(new THREE.Vector3(x, 0.1, z));
          }
        } catch (e) {
          console.error("Error calculating parametric point:", type, t, e);
        }
      }
      if (points.length > 1) {
        const curveGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const curveMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 3 });
        const curve = new THREE.Line(curveGeometry, curveMaterial);
        parametricGroup.add(curve);
        parametricPath = curve;
        let objectGeometry;
        let objectColor = 0xffaa00;
        switch (type) {
          case 'circle': objectGeometry = new THREE.SphereGeometry(0.3, 16, 16); objectColor = 0xff0000; break;
          case 'cycloid': objectGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.6); objectColor = 0x0000ff; break;
          case 'lissajous': objectGeometry = new THREE.TorusKnotGeometry(0.2, 0.05, 50, 8); objectColor = 0xffffff; break;
          case 'butterfly': objectGeometry = new THREE.OctahedronGeometry(0.35); objectColor = 0xff00ff; break;
          default: objectGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        }
        const objectMaterial = new THREE.MeshStandardMaterial({ color: objectColor, emissive: objectColor, emissiveIntensity: 0.4 });
        const object = new THREE.Mesh(objectGeometry, objectMaterial);
        object.castShadow = true;
        parametricGroup.add(object);
        parametricObject = object;
        parametricObject.userData = { type: type, a: a, b: b, tMax: tMax };
        appState.paramTime = 0;
        const startPos = getParametricPointForAnim(0, type, a, b);
        if (startPos) parametricObject.position.copy(startPos);
        else console.warn("Could not get start position for parametric object");
      } else {
        console.warn("Not enough valid points to draw parametric path for:", type);
        parametricPath = null;
        parametricObject = null;
      }
      return parametricPath;
    }

    function getParametricPointForAnim(t, type, a, b) {
      let x=0, z=0;
      try {
        switch (type) {
          case 'circle': x = a * Math.cos(t); z = a * Math.sin(t); break;
          case 'cycloid': x = a * (t - Math.sin(t)); z = a * (1 - Math.cos(t)); break;
          case 'lissajous': x = a * Math.sin(2 * t); z = b * Math.sin(3 * t); break;
          case 'butterfly':
            const cosT = Math.cos(t);
            const sinT = Math.sin(t);
            const expr = (Math.exp(cosT) - 2 * Math.cos(4 * t) - Math.pow(Math.sin(t / 12), 5));
            x = a * sinT * expr;
            z = a * cosT * expr;
            break;
          default: return null;
        }
        if (isNaN(x) || isNaN(z) || !isFinite(x) || !isFinite(z)) return null;
        return new THREE.Vector3(x, 0.1, z);
      } catch (e) {
        console.error("Error calculating parametric point for anim:", type, t, e);
        return null;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();
      if (controls && controls.enabled) {
        controls.update();
      }
      if (appState.animationRunning && parametricObject && parametricObject.visible && parametricObject.userData && parametricObject.userData.type) {
        const { type, a, b, tMax } = parametricObject.userData;
        const speed = parseFloat(document.getElementById('param-speed').value);
        appState.paramTime += delta * speed;
        if (tMax && appState.paramTime > tMax) {
          appState.paramTime = appState.paramTime % tMax;
        }
        const currentPos = getParametricPointForAnim(appState.paramTime, type, a, b);
        if(currentPos){
          parametricObject.position.copy(currentPos);
          const lookAheadTime = appState.paramTime + 0.05 * speed;
          const nextPos = getParametricPointForAnim(lookAheadTime, type, a, b);
          if (nextPos && nextPos.distanceTo(currentPos) > 0.01) {
            const lookTarget = nextPos.clone().setY(parametricObject.position.y);
            parametricObject.lookAt(lookTarget);
          }
        }
      }
      const waterMaterial = scene.children.find(c => c.geometry instanceof THREE.PlaneGeometry)?.material;
      if(waterMaterial && waterMaterial.map) {
        const time = clock.getElapsedTime() * 0.1;
        waterMaterial.map.offset.x = Math.sin(time * 2) * 0.02;
        waterMaterial.map.offset.y = Math.cos(time) * 0.02;
        waterMaterial.needsUpdate = true;
      }
      renderer.render(scene, camera);
    }

    function initEventListeners() {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', () => {
          const module = tab.getAttribute('data-module');
          handleTabClick(module);
        });
      });
      document.querySelectorAll('.module-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const module = btn.getAttribute('data-module');
          handleTabClick(module);
        });
      });
      startMissionBtn.addEventListener('click', () => {
        gsap.to(welcomeModal, {duration: 0.3, opacity: 0, y: 30, ease: "power1.in", onComplete: () => welcomeModal.style.display = 'none' });
        centerMap();
      });
      closeInfoModalBtn.addEventListener('click', () => infoModal.style.display = 'none');
      closeHelpModalBtn.addEventListener('click', () => helpModal.style.display = 'none');
      document.getElementById('return-overview').addEventListener('click', () => {
        handleTabClick('overview');
      });
      document.getElementById('show-help-header').addEventListener('click', showActionHelp);
      document.getElementById('triangle-select').addEventListener('change', updateTriangleProblem);
      document.getElementById('triangle-problem-type').addEventListener('change', setupTriangleInputs);
      document.getElementById('solve-triangle').addEventListener('click', solveTriangle);
      document.getElementById('triangle-hint-btn').addEventListener('click', toggleHintVisibility);
      document.getElementById('complete-triangulation').addEventListener('click', () => completeTask('triangulation'));
      ['vector1-x', 'vector1-y', 'vector1-z', 'vector2-x', 'vector2-y', 'vector2-z'].forEach(id => {
        document.getElementById(id).addEventListener('input', updateVectors);
      });
      document.getElementById('calculate-vector').addEventListener('click', updateVectors);
      document.getElementById('calculate-dot-product').addEventListener('click', calculateDotProduct);
      document.getElementById('vector-hint-btn').addEventListener('click', toggleHintVisibility);
      document.getElementById('complete-vectors').addEventListener('click', () => completeTask('vectors'));
      document.getElementById('polar-a').addEventListener('input', () => { updatePolarParams(); updatePolarCurve(); });
      document.getElementById('polar-n').addEventListener('input', () => { updatePolarParams(); updatePolarCurve(); });
      document.getElementById('polar-type').addEventListener('change', () => { updatePolarParams(); updatePolarCurve(); });
      document.getElementById('convert-polar').addEventListener('click', convertPolar);
      document.getElementById('polar-hint-btn').addEventListener('click', toggleHintVisibility);
      document.getElementById('complete-polar').addEventListener('click', () => completeTask('polar'));
      document.getElementById('param-speed').addEventListener('input', updateParametricSpeed);
      document.getElementById('param-a').addEventListener('input', () => { updateParametricParams(); updateParametricPathVisuals(); });
      document.getElementById('param-b').addEventListener('input', () => { updateParametricParams(); updateParametricPathVisuals(); });
      document.getElementById('parametric-type').addEventListener('change', () => { updateParametricParams(); updateParametricPathVisuals(); });
      document.getElementById('toggle-animation').addEventListener('click', toggleAnimation);
      document.getElementById('parametric-hint-btn').addEventListener('click', toggleHintVisibility);
      document.getElementById('complete-parametric').addEventListener('click', () => completeTask('parametric'));
    }

    function toggleHintVisibility(event) {
      const button = event.target;
      const hint = button.nextElementSibling;
      if (hint && hint.classList.contains('hint')) {
        const isHidden = hint.style.display === 'none' || hint.style.display === '';
        gsap.to(hint, { duration: 0.3, height: isHidden ? 'auto' : 0, opacity: isHidden ? 1 : 0, onStart: () => { if(isHidden) hint.style.display = 'block'; }, onComplete: () => { if(!isHidden) hint.style.display = 'none'; } });
      }
    }

    function handleTabClick(module) {
      const previousContentModule = appState.currentModule;
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      const clickedTab = document.querySelector(`.tab[data-module="${module}"]`);
      if (clickedTab) clickedTab.classList.add('active');
      if (module === 'center-map') {
        centerMap();
        const prevContentTab = document.querySelector(`.tab[data-module="${previousContentModule}"]`);
        if(prevContentTab) prevContentTab.classList.add('active');
        return;
      }
      if (module === 'zoom-in') {
        zoomInOnModule();
        const prevContentTab = document.querySelector(`.tab[data-module="${previousContentModule}"]`);
        if(prevContentTab) prevContentTab.classList.add('active');
        return;
      }
      if (module === 'info') {
        showInfo();
        const prevContentTab = document.querySelector(`.tab[data-module="${previousContentModule}"]`);
        if(prevContentTab) prevContentTab.classList.add('active');
        return;
      }
      if (module === 'help') {
        showActionHelp();
        const prevContentTab = document.querySelector(`.tab[data-module="${previousContentModule}"]`);
        if(prevContentTab) prevContentTab.classList.add('active');
        return;
      }
      if (contentModules.includes(module)) {
        switchModule(module);
      } else {
        console.warn("Unhandled tab module:", module);
        const prevContentTab = document.querySelector(`.tab[data-module="${previousContentModule}"]`);
        if (clickedTab) clickedTab.classList.remove('active');
        if (prevContentTab) prevContentTab.classList.add('active');
      }
    }

    function switchModule(module) {
      if (!contentModules.includes(module)) return;
      if (module === appState.currentModule) return;
      const previousModule = appState.currentModule;
      appState.currentModule = module;
      const previousElement = document.getElementById(previousModule);
      const activeElement = document.getElementById(module);
      if (previousElement) {
        gsap.to(previousElement, { duration: 0.2, opacity: 0, onComplete: () => {
          previousElement.classList.remove('active');
          if (activeElement) {
            activeElement.style.opacity = 0;
            activeElement.classList.add('active');
            gsap.to(activeElement, { duration: 0.3, opacity: 1 });
          }
        }});
      } else if (activeElement) {
        activeElement.style.opacity = 0;
        activeElement.classList.add('active');
        gsap.to(activeElement, { duration: 0.3, opacity: 1 });
      }
      triangleGroup.visible = (module === 'triangulation');
      vectorGroup.visible = (module === 'vectors');
      polarGroup.visible = (module === 'polar');
      parametricGroup.visible = (module === 'parametric');
      document.querySelectorAll('.hint').forEach(hint => {
        hint.style.display = 'none';
        hint.style.height = '';
        hint.style.opacity = '';
      });
      focusCameraOnModule(module);
      switch(module) {
        case 'triangulation':
          updateTriangleProblem();
          break;
        case 'vectors':
          updateVectors();
          break;
        case 'polar':
          updatePolarParams();
          updatePolarCurve();
          break;
        case 'parametric':
          updateParametricParams();
          updateParametricPathVisuals();
          break;
        case 'overview':
          updateProgress();
          break;
      }
    }

    function centerMap() {
      console.log("Centering map...");
      if (!controls || !gsap) return;
      controls.target.set(0, 0, 0);
      gsap.to(camera.position, {
        duration: 0.8,
        x: 0,
        y: 25,
        z: 40,
        ease: "power2.out",
        onUpdate: () => camera.lookAt(controls.target)
      });
      gsap.to(controls.target, {
        duration: 0.8,
        x: 0,
        y: 0,
        z: 0,
        ease: "power2.out"
      });
    }

    function zoomInOnModule() {
      console.log("Zooming in on module:", appState.currentModule);
      if (!controls || !gsap) return;
      let targetPosition = new THREE.Vector3(0, 0, 0);
      let zoomDistance = 15;
      let lookOffset = new THREE.Vector3(0, 0, 0);
      switch (appState.currentModule) {
        case 'triangulation':
          const selectedTriangleIndex = parseInt(document.getElementById('triangle-select').value) - 1;
          const targetTriangle = triangleRegions[selectedTriangleIndex];
          if (targetTriangle) {
            if(!targetTriangle.geometry.boundingSphere) targetTriangle.geometry.computeBoundingSphere();
            const center = targetTriangle.geometry.boundingSphere.center.clone();
            targetPosition = targetTriangle.localToWorld(center);
            zoomDistance = 10;
          }
          break;
        case 'vectors':
          targetPosition = vectorGroup.position.clone();
          zoomDistance = 10;
          break;
        case 'polar':
          targetPosition = polarGroup.position.clone();
          zoomDistance = 15;
          gsap.to(camera.position, {
            duration: 0.8,
            x: targetPosition.x,
            y: targetPosition.y + zoomDistance,
            z: targetPosition.z + 1,
            ease: "power2.out",
            onUpdate: () => camera.lookAt(controls.target)
          });
          gsap.to(controls.target, { duration: 0.8, x: targetPosition.x, y: targetPosition.y, z: targetPosition.z, ease: "power2.out" });
          return;
        case 'parametric':
          targetPosition = parametricGroup.position.clone();
          if (parametricObject && parametricObject.visible) {
            targetPosition = parametricObject.position.clone();
          }
          zoomDistance = 18;
          break;
        default:
          targetPosition = island.position.clone();
          zoomDistance = 25;
      }
      const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      if (direction.lengthSq() < 0.0001) direction.set(0, 0.5, 0.5).normalize();
      const newCamPos = new THREE.Vector3().addVectors(targetPosition, direction.multiplyScalar(zoomDistance));
      gsap.to(camera.position, {
        duration: 0.8,
        x: newCamPos.x,
        y: Math.max(newCamPos.y, 5),
        z: newCamPos.z,
        ease: "power2.out",
        onUpdate: () => camera.lookAt(controls.target)
      });
      gsap.to(controls.target, {
        duration: 0.8,
        x: targetPosition.x + lookOffset.x,
        y: targetPosition.y + lookOffset.y,
        z: targetPosition.z + lookOffset.z,
        ease: "power2.out"
      });
    }

    function focusCameraOnModule(module) {
      if (!controls || !gsap) return;
      let targetPosition = new THREE.Vector3(0, 0, 0);
      let idealDistance = 25;
      switch (module) {
        case 'triangulation':
          const selectedTriangleIndex = parseInt(document.getElementById('triangle-select').value) - 1;
          const targetTriangle = triangleRegions[selectedTriangleIndex];
          if (targetTriangle) {
            if(!targetTriangle.geometry.boundingSphere) targetTriangle.geometry.computeBoundingSphere();
            const center = targetTriangle.geometry.boundingSphere.center.clone();
            targetPosition = targetTriangle.localToWorld(center);
            idealDistance = 12;
          }
          break;
        case 'vectors':
          targetPosition = vectorGroup.getWorldPosition(new THREE.Vector3());
          idealDistance = 12;
          break;
        case 'polar':
          targetPosition = polarGroup.getWorldPosition(new THREE.Vector3());
          idealDistance = 20;
          gsap.to(camera.position, {
            duration: 0.6, x: targetPosition.x, y: targetPosition.y + idealDistance, z: targetPosition.z + 1,
            ease: "power1.out", overwrite: true, onUpdate: () => camera.lookAt(controls.target)
          });
          gsap.to(controls.target, { duration: 0.6, x: targetPosition.x, y: targetPosition.y, z: targetPosition.z, ease: "power1.out", overwrite: true });
          return;
        case 'parametric':
          targetPosition = parametricGroup.getWorldPosition(new THREE.Vector3());
          idealDistance = 22;
          break;
        default:
          targetPosition.set(0,0,0);
          idealDistance = 35;
      }
      const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      if (direction.lengthSq() < 0.0001) direction.set(0, 0.5, 0.5).normalize();
      const newCamPos = new THREE.Vector3().addVectors(targetPosition, direction.multiplyScalar(idealDistance));
      gsap.to(controls.target, { duration: 0.6, x: targetPosition.x, y: targetPosition.y, z: targetPosition.z, ease: "power1.out", overwrite: true});
      gsap.to(camera.position, { duration: 0.6, x: newCamPos.x, y: Math.max(newCamPos.y, 5), z: newCamPos.z, ease: "power1.out", overwrite: true, onUpdate: () => camera.lookAt(controls.target) });
    }

    function showInfo() {
      gsap.from(infoModal, { duration: 0.4, opacity: 0, scale: 0.9, ease: "back.out(1.7)", onStart: () => infoModal.style.display = 'block'});
    }

    function showActionHelp() {
      gsap.from(helpModal, { duration: 0.4, opacity: 0, scale: 0.9, ease: "back.out(1.7)", onStart: () => helpModal.style.display = 'block'});
    }

    function updateTriangleProblem() {
      const select = document.getElementById('triangle-select');
      const regionIndex = parseInt(select.value) - 1;
      const data = triangleData[regionIndex];
      if (!data) return;
      const infoDiv = document.getElementById('triangle-info');
      infoDiv.innerHTML = `
        <strong>${data.name}</strong><br>
        Default problem: ${data.defaultProblem}<br>
        <small>Initial knowns: Sides=${data.sides.map((s, i) => s > 0 ? `${String.fromCharCode(97 + i)}=${s}` : '').filter(Boolean).join(', ') || 'N/A'}, Angles=${data.angles.map((a, i) => a > 0 ? `${String.fromCharCode(65 + i)}=${a}°` : '').filter(Boolean).join(', ') || 'N/A'}</small>
      `;
      triangleRegions.forEach((mesh, index) => {
        mesh.material.emissive.setHex(index === regionIndex ? 0x555555 : 0x000000);
        mesh.material.needsUpdate = true;
      });
      document.getElementById('triangle-problem-type').value = data.defaultProblem;
      setupTriangleInputs();
      document.getElementById('triangle-result').innerHTML = '<p>Enter known values and click Calculate.</p>';
      const triangleMesh = triangleRegions[regionIndex];
      if(triangleMesh) {
        while(triangleMesh.children.length > 0) {
          const child = triangleMesh.children[0];
          if (child.material) {
            if(child.material.map) child.material.map.dispose();
            child.material.dispose();
          }
          if(child.geometry) child.geometry.dispose();
          triangleMesh.remove(child);
        }
      }
      if(appState.currentModule === 'triangulation') {
        focusCameraOnModule('triangulation');
      }
    }

    function setupTriangleInputs() {
      const problemType = document.getElementById('triangle-problem-type').value;
      const inputsDiv = document.getElementById('triangle-inputs');
      const regionIndex = parseInt(document.getElementById('triangle-select').value) - 1;
      const data = triangleData[regionIndex] || { sides: [0,0,0], angles: [0,0,0] };
      let html = '';
      const createInput = (type, label, id, value = '', step = 0.1, min = 0, max = '') => {
        let displayValue = '';
        const defaultProblem = triangleData[regionIndex]?.defaultProblem;
        if (problemType === defaultProblem) {
          if (id === 'triangle-side-a' && data.sides[0] > 0) displayValue = data.sides[0];
          else if (id === 'triangle-side-b' && data.sides[1] > 0) displayValue = data.sides[1];
          else if (id === 'triangle-side-c' && data.sides[2] > 0) displayValue = data.sides[2];
          else if (id === 'triangle-angle-a' && data.angles[0] > 0) displayValue = data.angles[0];
          else if (id === 'triangle-angle-b' && data.angles[1] > 0) displayValue = data.angles[1];
          else if (id === 'triangle-angle-c' && data.angles[2] > 0) displayValue = data.angles[2];
          else displayValue = value;
        } else {
          displayValue = value;
        }
        return `
            <div class="input-group">
              <label for="${id}">${label}:</label>
              <input type="${type}" id="${id}" step="${step}" min="${min}" ${max ? `max="${max}"` : ''} placeholder="${value || 'Enter value'}" value="${displayValue}">
            </div>`;
      }
      switch (problemType) {
        case 'SSS':
          html = createInput('number', 'Side a', 'triangle-side-a', 'e.g., 12') +
                 createInput('number', 'Side b', 'triangle-side-b', 'e.g., 8') +
                 createInput('number', 'Side c', 'triangle-side-c', 'e.g., 10');
          break;
        case 'SAS':
          html = createInput('number', 'Side a', 'triangle-side-a', 'e.g., 9') +
                 createInput('number', 'Angle C (°)', 'triangle-angle-c', 'e.g., 45', 1, 0.1, 179.9) +
                 createInput('number', 'Side b', 'triangle-side-b', 'e.g., 11');
          break;
        case 'ASA':
          html = createInput('number', 'Angle A (°)', 'triangle-angle-a', 'e.g., 50', 1, 0.1, 179.8) +
                 createInput('number', 'Side c (between A, B)', 'triangle-side-c', 'e.g., 7') +
                 createInput('number', 'Angle B (°)', 'triangle-angle-b', 'e.g., 60', 1, 0.1, 179.8);
          break;
        case 'AAS':
          html = createInput('number', 'Angle A (°)', 'triangle-angle-a', 'e.g., 50', 1, 0.1, 179.8) +
                 createInput('number', 'Angle B (°)', 'triangle-angle-b', 'e.g., 60', 1, 0.1, 179.8) +
                 createInput('number', 'Side a (opposite A)', 'triangle-side-a', 'e.g., 7');
          break;
      }
      inputsDiv.innerHTML = html;
      document.getElementById('triangle-result').innerHTML = '<p>Enter known values and click Calculate.</p>';
    }

    function solveTriangle() {
      const problemType = document.getElementById('triangle-problem-type').value;
      const resultDiv = document.getElementById('triangle-result');
      const { sin, cos, asin, acos, sqrt, PI } = Math;
      const toRad = angle => angle * PI / 180;
      const toDeg = rad => rad * 180 / PI;
      let a=NaN, b=NaN, c=NaN, A=NaN, B=NaN, C=NaN;
      let area = NaN;
      const TOLERANCE = 1e-9;
      resultDiv.classList.remove('error');
      const existingCompletion = resultDiv.querySelector('.completion-message');
      if (existingCompletion) existingCompletion.remove();
      try {
        if (problemType === 'SSS') {
          a = parseFloat(document.getElementById('triangle-side-a').value);
          b = parseFloat(document.getElementById('triangle-side-b').value);
          c = parseFloat(document.getElementById('triangle-side-c').value);
          if (isNaN(a) || isNaN(b) || isNaN(c) || a <= TOLERANCE || b <= TOLERANCE || c <= TOLERANCE) throw new Error("Valid positive side lengths required.");
          if (a + b <= c + TOLERANCE || a + c <= b + TOLERANCE || b + c <= a + TOLERANCE) throw new Error("Triangle inequality violated (sides cannot form a triangle).");
          let cosA = (b * b + c * c - a * a) / (2 * b * c);
          let cosB = (a * a + c * c - b * b) / (2 * a * c);
          cosA = Math.max(-1, Math.min(1, cosA));
          cosB = Math.max(-1, Math.min(1, cosB));
          A = toDeg(acos(cosA));
          B = toDeg(acos(cosB));
          C = 180 - A - B;
          if (isNaN(A) || isNaN(B) || isNaN(C) || A < TOLERANCE || B < TOLERANCE || C < TOLERANCE || Math.abs(A+B+C - 180) > TOLERANCE * 10) {
            throw new Error("Could not calculate valid angles (check inputs).");
          }
        } else if (problemType === 'SAS') {
          a = parseFloat(document.getElementById('triangle-side-a').value);
          C = parseFloat(document.getElementById('triangle-angle-c').value);
          b = parseFloat(document.getElementById('triangle-side-b').value);
          if (isNaN(a) || isNaN(b) || isNaN(C) || a <= TOLERANCE || b <= TOLERANCE || C <= TOLERANCE || C >= 180 - TOLERANCE) throw new Error("Valid positive sides and angle (0 < C < 180) required.");
          const Crad = toRad(C);
          c = sqrt(a * a + b * b - 2 * a * b * cos(Crad));
          if (isNaN(c) || c <= TOLERANCE) throw new Error("Could not calculate valid side c.");
          let cosA = (b * b + c * c - a * a) / (2 * b * c);
          cosA = Math.max(-1, Math.min(1, cosA));
          A = toDeg(acos(cosA));
          B = 180 - A - C;
          if (isNaN(A) || isNaN(B) || A < TOLERANCE || B < TOLERANCE || Math.abs(A+B+C - 180) > TOLERANCE * 10) throw new Error("Could not calculate valid remaining angles.");
        } else if (problemType === 'ASA') {
          A = parseFloat(document.getElementById('triangle-angle-a').value);
          c = parseFloat(document.getElementById('triangle-side-c').value);
          B = parseFloat(document.getElementById('triangle-angle-b').value);
          if (isNaN(A) || isNaN(B) || isNaN(c) || A <= TOLERANCE || B <= TOLERANCE || c <= TOLERANCE || A + B >= 180 - TOLERANCE) throw new Error("Valid positive angles and side required (A+B < 180).");
          C = 180 - A - B;
          if (C <= TOLERANCE) throw new Error("Resulting angle C is too small or zero.");
          const Arad = toRad(A);
          const Brad = toRad(B);
          const Crad = toRad(C);
          a = c * sin(Arad) / sin(Crad);
          b = c * sin(Brad) / sin(Crad);
          if (isNaN(a) || isNaN(b) || a < TOLERANCE || b < TOLERANCE) throw new Error("Could not calculate valid remaining sides.");
        } else if (problemType === 'AAS') {
          A = parseFloat(document.getElementById('triangle-angle-a').value);
          B = parseFloat(document.getElementById('triangle-angle-b').value);
          a = parseFloat(document.getElementById('triangle-side-a').value);
          if (isNaN(A) || isNaN(B) || isNaN(a) || A <= TOLERANCE || B <= TOLERANCE || a <= TOLERANCE || A + B >= 180 - TOLERANCE) throw new Error("Valid positive angles and side required (A+B < 180).");
          C = 180 - A - B;
          if (C <= TOLERANCE) throw new Error("Resulting angle C is too small or zero.");
          const Arad = toRad(A);
          const Brad = toRad(B);
          const Crad = toRad(C);
          b = a * sin(Brad) / sin(Arad);
          c = a * sin(Crad) / sin(Arad);
          if (isNaN(b) || isNaN(c) || b < TOLERANCE || c < TOLERANCE) throw new Error("Could not calculate valid remaining sides.");
        } else {
          throw new Error("Unknown problem type selected.");
        }
        if (!isNaN(a) && !isNaN(b) && !isNaN(C) && C > TOLERANCE && C < 180 - TOLERANCE) {
          area = 0.5 * a * b * sin(toRad(C));
          if (isNaN(area) || area < TOLERANCE) area = NaN;
        } else {
          area = NaN;
        }
        resultDiv.innerHTML = `
          <strong>Calculated Values:</strong><br>
          Side a: ${a.toFixed(2)} units<br>
          Side b: ${b.toFixed(2)} units<br>
          Side c: ${c.toFixed(2)} units<br>
          Angle A: ${A.toFixed(2)}°<br>
          Angle B: ${B.toFixed(2)}°<br>
          Angle C: ${C.toFixed(2)}°<br>
          Area: ${isNaN(area) ? 'N/A' : area.toFixed(2) + ' sq. units'}<br>
          <small>(Sum of angles: ${(A + B + C).toFixed(2)}°)</small>
        `;
        updateTriangleGeometry(a, b, c, A, B, C);
      } catch (error) {
        resultDiv.innerHTML = `<p style="color: #ff6666;">Error: ${error.message || 'Invalid input or calculation failed.'}</p>`;
        resultDiv.classList.add('error');
        const regionIndex = parseInt(document.getElementById('triangle-select').value) - 1;
        const triangleMesh = triangleRegions[regionIndex];
        if (triangleMesh) {
          while (triangleMesh.children.length > 0) {
            const child = triangleMesh.children[0];
            if (child.material) {
              if(child.material.map) child.material.map.dispose();
              child.material.dispose();
            }
            if(child.geometry) child.geometry.dispose();
            triangleMesh.remove(child);
          }
        }
      }
    }

    // --- Correction: Updated Triangle Geometry Function ---
    function updateTriangleGeometry(a, b, c, A_deg, B_deg, C_deg) {
      const regionIndex = parseInt(document.getElementById('triangle-select').value) - 1;
      const triangleMesh = triangleRegions[regionIndex];
      if (!triangleMesh || isNaN(a) || isNaN(b) || isNaN(c) || isNaN(A_deg) || isNaN(B_deg) || isNaN(C_deg)) {
        console.warn("Cannot update triangle geometry, invalid values:", a,b,c,A_deg,B_deg,C_deg);
        return;
      }
      // Define toRad locally
      const toRad = angle => angle * Math.PI / 180;
      const A_rad = toRad(A_deg);
      // Define vertices:
      const vA = new THREE.Vector3(0, 0, 0); // Vertex A at origin
      const vC = new THREE.Vector3(b, 0, 0); // Vertex C along x-axis at distance b
      // Vertex B calculated using side c and angle A at A
      const vB = new THREE.Vector3(c * Math.cos(A_rad), 0, c * Math.sin(A_rad));
      const positions = triangleMesh.geometry.attributes.position;
      positions.setXYZ(0, vA.x, vA.y, vA.z);
      positions.setXYZ(1, vB.x, vB.y, vB.z);
      positions.setXYZ(2, vC.x, vC.y, vC.z);
      positions.needsUpdate = true;
      triangleMesh.geometry.computeVertexNormals();
      triangleMesh.geometry.computeBoundingSphere();
      const updatedData = { sides: [a, b, c], angles: [A_deg, B_deg, C_deg] };
      addTriangleMarkers(triangleMesh, updatedData);
    }

    function updateVectors() {
      const v1x = parseFloat(document.getElementById('vector1-x').value) || 0;
      const v1y = parseFloat(document.getElementById('vector1-y').value) || 0;
      const v1z = parseFloat(document.getElementById('vector1-z').value) || 0;
      const v2x = parseFloat(document.getElementById('vector2-x').value) || 0;
      const v2y = parseFloat(document.getElementById('vector2-y').value) || 0;
      const v2z = parseFloat(document.getElementById('vector2-z').value) || 0;
      createVector('vector1', v1x, v1y, v1z, 0xff0000);
      createVector('vector2', v2x, v2y, v2z, 0x00ff00);
      if (vectorArrows.resultVector) {
        const label = vectorGroup.children.find(child => child.userData.isLabel && child.userData.arrowName === 'resultVector');
        if (label) {
          if (label.material.map) label.material.map.dispose();
          label.material.dispose();
          vectorGroup.remove(label);
        }
        vectorGroup.remove(vectorArrows.resultVector);
        vectorArrows.resultVector = null;
      }
      const resultDiv = document.getElementById('vector-result');
      const mag1 = Math.sqrt(v1x * v1x + v1y * v1y + v1z * v1z);
      const mag2 = Math.sqrt(v2x * v2x + v2y * v2y + v2z * v2z);
      resultDiv.innerHTML = `
        <strong>Vector 1 (Red):</strong> (${v1x.toFixed(1)}, ${v1y.toFixed(1)}, ${v1z.toFixed(1)}) | Mag: ${mag1.toFixed(2)}<br>
        <strong>Vector 2 (Green):</strong> (${v2x.toFixed(1)}, ${v2y.toFixed(1)}, ${v2z.toFixed(1)}) | Mag: ${mag2.toFixed(2)}<br>
        <em id="dot-product-prompt">Click 'Calculate Dot Product' for angle analysis.</em>
        <div id="dot-product-results" style="margin-top: 5px;"></div>
      `;
      const existingCompletion = resultDiv.querySelector('.completion-message');
      if (existingCompletion) existingCompletion.remove();
    }

    function calculateDotProduct() {
      updateVectors();
      const v1Data = vectorArrows.vector1?.userData?.vectorData;
      const v2Data = vectorArrows.vector2?.userData?.vectorData;
      const resultsContainer = document.getElementById('dot-product-results');
      const prompt = document.getElementById('dot-product-prompt');
      if(prompt) prompt.style.display = 'none';
      if(!resultsContainer) return;
      if (!v1Data || !v2Data) {
        resultsContainer.innerHTML = '<p style="color: #ff6666;">Cannot calculate dot product: One or both vectors are zero length.</p>';
        return;
      }
      const { x: v1x, y: v1y, z: v1z } = v1Data;
      const { x: v2x, y: v2y, z: v2z } = v2Data;
      const dotProduct = v1x * v2x + v1y * v2y + v1z * v2z;
      const mag1 = Math.sqrt(v1x * v1x + v1y * v1y + v1z * v1z);
      const mag2 = Math.sqrt(v2x * v2x + v2y * v2y + v2z * v2z);
      let angleDegrees = NaN;
      let relationship = "N/A";
      const TOLERANCE = 1e-6;
      if (mag1 > TOLERANCE && mag2 > TOLERANCE) {
        let cosAngle = dotProduct / (mag1 * mag2);
        cosAngle = Math.max(-1, Math.min(1, cosAngle));
        angleDegrees = Math.acos(cosAngle) * 180 / Math.PI;
        if (Math.abs(dotProduct) < TOLERANCE) {
          relationship = 'Orthogonal (Perpendicular)';
          angleDegrees = 90;
        } else if (Math.abs(1 - cosAngle) < TOLERANCE) {
          relationship = 'Parallel (Same Direction)';
          angleDegrees = 0;
        } else if (Math.abs(-1 - cosAngle) < TOLERANCE) {
          relationship = 'Anti-parallel (Opposite Directions)';
          angleDegrees = 180;
        } else if (dotProduct > 0) {
          relationship = 'Acute Angle';
        } else {
          relationship = 'Obtuse Angle';
        }
      } else {
        relationship = 'One or both vectors have zero length.';
      }
      resultsContainer.innerHTML = `
        <hr style="margin: 5px 0; border-color: #4fd1c5;">
        <strong>Dot Product (v1 · v2):</strong> ${dotProduct.toFixed(2)}<br>
        <strong>Angle between vectors (θ):</strong> ${isNaN(angleDegrees) ? 'N/A' : angleDegrees.toFixed(1) + '°'}<br>
        <strong>Relationship:</strong> ${relationship}
      `;
      const sumX = v1x + v2x;
      const sumY = v1y + v2y;
      const sumZ = v1z + v2z;
      createVector('resultVector', sumX, sumY, sumZ, 0xffff00);
    }

    function updatePolarParams() {
      const a = parseFloat(document.getElementById('polar-a').value);
      const n = parseFloat(document.getElementById('polar-n').value);
      document.getElementById('polar-a-value').textContent = a.toFixed(1);
      document.getElementById('polar-n-value').textContent = n.toFixed(0);
      const type = document.getElementById('polar-type').value;
      const equationDiv = document.getElementById('polar-equation');
      let eqStr = "r = ";
      const aStr = a.toFixed(1);
      const nStr = n.toFixed(0);
      switch (type) {
        case 'rose': eqStr += `${aStr} · cos(${nStr}θ)`; break;
        case 'limaçon': eqStr += `1 + ${aStr} · cos(θ)`; break;
        case 'lemniscate': eqStr += `√(${aStr}² · cos(2θ))`; break;
        case 'cardioid': eqStr += `${aStr} · (1 + cos(θ))`; break;
        case 'spiral': eqStr += `${aStr} · θ / (2π)`; break;
        default: eqStr = "Select type";
      }
      equationDiv.innerHTML = eqStr;
      const resultDiv = document.getElementById('polar-result');
      const rectResult = resultDiv.querySelector('#polar-rect-result');
      if(rectResult) rectResult.innerHTML = '';
      const existingCompletion = resultDiv.querySelector('.completion-message');
      if (existingCompletion) existingCompletion.remove();
    }

    function updatePolarCurve() {
      const type = document.getElementById('polar-type').value;
      const a = parseFloat(document.getElementById('polar-a').value);
      const n = parseFloat(document.getElementById('polar-n').value);
      createPolarCurve(type, a, n);
      const resultDiv = document.getElementById('polar-result');
      let description = '';
      switch (type) {
        case 'rose':
          const petals = (n > 0 && n % 2 === 0) ? (2 * n) : (n > 0 ? n : 1);
          description = `Rose curve with ${petals} petal${petals !== 1 ? 's' : ''}.`;
          if (n===0) description = `Circle (r=${a.toFixed(1)}).`;
          break;
        case 'limaçon':
          if (Math.abs(a - 1) < 1e-6) description = `Cardioid (special Limaçon).`;
          else if (a > 1) description = `Dimpled Limaçon.`;
          else if (a < 1 && a > 0) description = `Limaçon with inner loop.`;
          else if (a === 0) description = `Circle (r=1).`;
          else description = `Limaçon.`;
          break;
        case 'lemniscate': description = `Lemniscate (figure-eight).`; break;
        case 'cardioid': description = `Cardioid (heart shape).`; break;
        case 'spiral': description = `Archimedean Spiral.`; break;
        default: description = "Selected feature.";
      }
      resultDiv.innerHTML = `
        <p><strong>Feature:</strong> ${description}</p>
        <p><strong>Current Equation:</strong> ${document.getElementById('polar-equation').innerHTML}</p>
        <p><strong>Parameters:</strong> a = ${a.toFixed(1)}, n = ${n.toFixed(0)}</p>
        <p id="polar-rect-result" style="font-size: 0.9em; margin-top: 5px;"></p>
      `;
    }

    function convertPolar() {
      const type = document.getElementById('polar-type').value;
      const a = parseFloat(document.getElementById('polar-a').value);
      const n = parseFloat(document.getElementById('polar-n').value);
      const resultP = document.getElementById('polar-rect-result');
      if (!resultP) return;
      let rectangularForm = 'Conversion is complex or not easily represented algebraically.';
      const aStr = a.toFixed(1);
      const aSqStr = (a*a).toFixed(1);
      const xSqPySq = '(x² + y²)';
      try {
        switch (type) {
          case 'cardioid':
            rectangularForm = `(${xSqPySq} - ${aStr}x)² = ${aSqStr}${xSqPySq}`;
            break;
          case 'lemniscate':
            rectangularForm = `${xSqPySq}² = ${aSqStr}(x² - y²)`;
            break;
          case 'limaçon':
            rectangularForm = `(${xSqPySq} - ${aStr}x)² = ${xSqPySq}`;
            break;
          case 'rose':
            if (n === 1) rectangularForm = `(x - ${a/2})² + y² = (${(a/2).toFixed(1)})²`;
            else if (n === 2) rectangularForm = `${xSqPySq}³ = ${aSqStr}(x² - y²)²`;
            else if (n === 0) rectangularForm = `x² + y² = ${aSqStr}`;
            else rectangularForm = `Complex for n=${n}`;
            break;
          case 'spiral':
            rectangularForm = `√(x²+y²) = (${aStr}/(2π)) · atan2(y, x)`;
            break;
        }
      } catch(e) {
        rectangularForm = 'Error during conversion attempt.';
        console.error("Polar conversion error:", e);
      }
      resultP.innerHTML = `<strong>Approx. Rectangular Form:</strong> ${rectangularForm}`;
    }

    function updateParametricSpeed() {
      const speed = parseFloat(document.getElementById('param-speed').value);
      document.getElementById('param-speed-value').textContent = speed.toFixed(1);
    }

    function updateParametricParams() {
      const a = parseFloat(document.getElementById('param-a').value);
      const b = parseFloat(document.getElementById('param-b').value);
      document.getElementById('param-a-value').textContent = a.toFixed(1);
      document.getElementById('param-b-value').textContent = b.toFixed(1);
      const type = document.getElementById('parametric-type').value;
      const equationDiv = document.getElementById('parametric-equation');
      let xEq = "x(t) = ";
      let zEq = "z(t) = ";
      const aStr = a.toFixed(1);
      const bStr = b.toFixed(1);
      switch (type) {
        case 'circle': xEq += `${aStr}·cos(t)`; zEq += `${aStr}·sin(t)`; break;
        case 'cycloid': xEq += `${aStr}·(t - sin(t))`; zEq += `${aStr}·(1 - cos(t))`; break;
        case 'lissajous': xEq += `${aStr}·sin(2t)`; zEq += `${bStr}·sin(3t)`; break;
        case 'butterfly':
          xEq += `${aStr}·sin(t)·[e<sup>cos(t)</sup> - 2cos(4t) - sin<sup>5</sup>(t/12)]`;
          zEq += `${aStr}·cos(t)·[e<sup>cos(t)</sup> - 2cos(4t) - sin<sup>5</sup>(t/12)]`;
          break;
        default: xEq += "..."; zEq += "...";
      }
      equationDiv.innerHTML = `${xEq}<br>${zEq}`;
      const resultDiv = document.getElementById('parametric-result');
      const existingCompletion = resultDiv.querySelector('.completion-message');
      if (existingCompletion) existingCompletion.remove();
    }

    function updateParametricPathVisuals() {
      const type = document.getElementById('parametric-type').value;
      const a = parseFloat(document.getElementById('param-a').value);
      const b = parseFloat(document.getElementById('param-b').value);
      updateParametricPath(type, a, b);
      const resultDiv = document.getElementById('parametric-result');
      let description = '';
      switch (type) {
        case 'circle': description = `Circular path (Radius ≈ ${a.toFixed(1)})`; break;
        case 'cycloid': description = `Cycloid path (Rolling circle radius ≈ ${a.toFixed(1)})`; break;
        case 'lissajous': description = `Lissajous curve (Amplitudes ≈ ${a.toFixed(1)}, ${b.toFixed(1)}, Freqs 2:3)`; break;
        case 'butterfly': description = `Butterfly curve (Scale ≈ ${a.toFixed(1)})`; break;
        default: description = "Selected path.";
      }
      resultDiv.innerHTML = `
        <p><strong>Path Type:</strong> ${description}</p>
        <p><strong>Current Equations:</strong><br>${document.getElementById('parametric-equation').innerHTML}</p>
        <p><strong>Parameters:</strong> a = ${a.toFixed(1)}, b = ${b.toFixed(1)}</p>
      `;
      const existingCompletion = resultDiv.querySelector('.completion-message');
      if (existingCompletion) existingCompletion.remove();
    }

    function toggleAnimation() {
      appState.animationRunning = !appState.animationRunning;
      document.getElementById('toggle-animation').textContent = appState.animationRunning ? 'Pause Animation' : 'Resume Animation';
    }

    function completeTask(task) {
      if (!appState.completedTasks[task]) {
        appState.completedTasks[task] = true;
        updateProgress();
        const resultDiv = document.getElementById(`${task}-result`);
        if (resultDiv) {
          const existingMsg = resultDiv.querySelector('.completion-message');
          if (existingMsg) existingMsg.remove();
          const completionMsgHTML = `<p class="completion-message">✓ Task marked as complete!</p>`;
          resultDiv.insertAdjacentHTML('beforeend', completionMsgHTML);
        }
        const button = document.getElementById(`complete-${task}`);
        if (button) {
          button.disabled = true;
          button.textContent = '✓ Completed';
          button.style.backgroundColor = '#555';
          button.style.cursor = 'default';
        }
        const allCompleted = Object.values(appState.completedTasks).every(status => status);
        if (allCompleted) {
          setTimeout(showCompletion, 500);
        }
      }
    }

    function updateProgress() {
      const completedCount = Object.values(appState.completedTasks).filter(status => status).length;
      const totalTasks = Object.keys(appState.completedTasks).length;
      const progressText = document.querySelector('#progress-display p');
      if(progressText) {
        progressText.textContent = `Tasks completed: ${completedCount}/${totalTasks}`;
      }
      const overviewProgressBarContainer = document.querySelector('#progress-display');
      if (overviewProgressBarContainer) {
        let progressBarDiv = overviewProgressBarContainer.querySelector('.progress-bar-visual');
        if (!progressBarDiv) {
          const barContainer = document.createElement('div');
          barContainer.style.cssText = `background-color: rgba(79, 209, 197, 0.2); height: 10px; border-radius: 5px; margin-top: 5px; overflow: hidden; border: 1px solid #38b2ac;`;
          progressBarDiv = document.createElement('div');
          progressBarDiv.className = 'progress-bar-visual';
          progressBarDiv.style.cssText = `background-color: #4fd1c5; width: 0%; height: 100%; border-radius: 5px; transition: width 0.4s ease-out;`;
          barContainer.appendChild(progressBarDiv);
          overviewProgressBarContainer.appendChild(barContainer);
        }
        const percentage = totalTasks > 0 ? (completedCount / totalTasks) * 100 : 0;
        progressBarDiv.style.width = `${percentage}%`;
        progressBarDiv.style.borderTopRightRadius = (percentage === 100) ? '5px' : '0px';
        progressBarDiv.style.borderBottomRightRadius = (percentage === 100) ? '5px' : '0px';
      }
      document.querySelectorAll('.progress-item').forEach((item, index) => {
        const tasks = ['triangulation', 'vectors', 'polar', 'parametric'];
        const taskName = tasks[index];
        const checkSpan = item.querySelector('.progress-check');
        const taskTextSpan = item.querySelector('span:last-child');
        if (appState.completedTasks[taskName]) {
          checkSpan.innerHTML = '✔️';
          item.classList.add('completed');
          checkSpan.style.color = '#48bb78';
        } else {
          checkSpan.innerHTML = '☐';
          item.classList.remove('completed');
          checkSpan.style.color = '#4fd1c5';
        }
      });
    }

    function showCompletion() {
      if (document.getElementById('completion-modal-instance')) return;
      const overlay = document.createElement('div');
      overlay.id = 'modal-overlay';
      overlay.style.cssText = `
          position: fixed; top: 0; left: 0; width: 100%; height: 100%;
          background-color: rgba(0, 0, 0, 0.6); z-index: 199; display: block; backdrop-filter: blur(3px);
      `;
      document.body.appendChild(overlay);
      const completionModal = document.createElement('div');
      completionModal.id = 'completion-modal-instance';
      completionModal.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          width: 90%; max-width: 600px; background-color: rgba(10, 10, 40, 0.9);
          border-radius: 15px; padding: 25px; z-index: 200;
          box-shadow: 0 0 25px rgba(79, 209, 197, 0.7); color: white;
          border: 1px solid #4fd1c5; opacity: 0;
      `;
      completionModal.innerHTML = `
        <h1 style="color: #4fd1c5; text-align: center; margin-bottom: 20px; font-size: 1.8em;">✨ Mission Accomplished! ✨</h1>
        <p style="text-align: center; font-size: 1.1em; margin-bottom: 15px;">Congratulations, explorer! You have successfully mapped Trigonomia Island using your mathematical prowess!</p>
        <p>Your expedition meticulously documented:</p>
        <ul style="list-style: none; padding-left: 10px; margin-bottom: 15px;">
          <li style="margin-bottom: 8px;"><span style="color: #48bb78;">✔️</span> Key land region dimensions via <strong>Triangulation</strong>.</li>
          <li style="margin-bottom: 8px;"><span style="color: #48bb78;">✔️</span> Directional forces and patterns using <strong>Vectors</strong>.</li>
          <li style="margin-bottom: 8px;"><span style="color: #48bb78;">✔️</span> Unique natural formations with <strong>Polar Coordinates</strong>.</li>
          <li style="margin-bottom: 8px;"><span style="color: #48bb78;">✔️</span> Movement and migration paths via <strong>Parametric Equations</strong>.</li>
        </ul>
        <p style="text-align: center; font-style: italic;">Your map is a vital contribution to understanding this mysterious island!</p>
        <div style="text-align: center; margin-top: 25px;">
          <button id="close-completion" class="modal-close-btn" style="background-color: #4fd1c5; color: black; font-weight: bold;">Return to Island View</button>
        </div>
      `;
      document.body.appendChild(completionModal);
      const closeBtn = document.getElementById('close-completion');
      const closeHandler = () => {
        if (!gsap) {
          if (completionModal) completionModal.remove();
          if (overlay) overlay.remove();
          return;
        }
        gsap.to(completionModal, { duration: 0.3, opacity: 0, scale: 0.9, ease: "power1.in", onComplete: () => {
          if (completionModal) completionModal.remove();
          if (overlay) overlay.remove();
        }});
      };
      if(closeBtn) closeBtn.addEventListener('click', closeHandler, { once: true });
      overlay.addEventListener('click', closeHandler, { once: true });
      if (gsap) {
        gsap.to(completionModal, { duration: 0.5, opacity: 1, scale: 1, ease: "back.out(1.7)" });
      } else {
        completionModal.style.opacity = 1;
      }
    }

    function init() {
      loadScript('https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js', () => {
        console.log("GSAP loaded.");
        initLoading();
        initScene();
        initEventListeners();
        updateProgress();
        switchModule('overview');
        if(triangleData.length > 0){
          document.getElementById('triangle-select').value = '1';
          updateTriangleProblem();
        }
      });
    }

    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
